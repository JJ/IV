# Objetivo 6: Integración continua

## Descripción

El principal objetivo de este hito del proyecto es añadir
[integración continua](http://jj.github.io/IV/documentos/temas/Integracion_continua)
al mismo. Los tres subobjetivos son aprender cómo describir la versión del
lenguaje de programación que se usa en el proyecto y la infraestructura que
necesita para funcionar, así como la elección de un sistema y sitio para
integración continua y configuración del mismo.

## Prerrequisitos

Haber superado los tests en el [objetivo anterior, contenedores](5.Docker.md).

## TL;DR

La infraestructura virtual definida en el anterior objetivo para darle soporte a
las tareas que se tienen que realizar durante el desarrollo y eventual
despliegue debe ponerse en funcionamiento. Deberá entenderse el siguiente nivel
de definición de esta infraestructura en sistemas de integración continua, y
aplicar una vez más (como se hace desde el objetivo 3) una metodología sólida
para tomar decisiones técnicas sobre las herramientas usadas en el desarrollo.

## Explicación

En sistemas de desarrollo ágil quien desarrolle tiene que asegurar que el código
pasa todos los tests antes de ser desplegado o simplemente incorporado a la rama
principal, porque los tests deben comprobar que se han resuelto los problemae
expresados en la historia de usuario. Para ello se escriben una serie de tests
que se ejecutan automáticamente al añadir o modificar código o cuando se cree un
*pull request*.

Estos tests tienen el fin obvio de asegurar la calidad del mismo
(via implementación de las pruebas para que se cumplan las historias de
usuario), pero también en un entorno de desarrollo colaborativo permiten
integrar código fácilmente asegurándose de que no se *rompa* nada, en un proceso
denominado *integración continua*. Si no está *testeado*, está roto, es el lema
del desarrollador. Al ser la plasmación de las especificaciones, en cada
incorporación de código la ejecución automática de los tests asegura que el
código sigue cumpliendo las especificaciones. En este hito lo que haremos será
configurar nuestro repositorio para que se pasen los tests, posiblemente en
diferentes ambientes, automáticamente.

Y que *no se rompa nada* se tiene que hacer a diferentes niveles, porque no
sabemos, en principio, donde vamos a desplegar nuestra aplicación; aunque en
general tenemos un control bastante completo sobre los entornos de despliegue,
puede suceder que las versiones de alguna de las herramientas estén limitadas, y
en todo caso que esas herramientas evolucionen de una forma determinada en el
futuro y que deje de funcionar nuestro programa. Por eso, hay que prevenirse
frente a estos problemas. Empezando por el lenguaje de programación, debería
testearse
- La versión estable del lenguaje que exista en cada momento. Esta versión
  estable puede cambiar, por lo que el sistema de integración continua debe
  asegurarse que efectivamente sea la versión estable, no la versión que en un
  momento determinado del tiempo lo sea.
- Las versiones LTS son versiones que tienen soporte y que puede ser el ambiente
  con el que se encuentre uno a la hora de desplegar.
- Las versiones de desarrollo incorporarán nuevas características, pero también
  pueden cambiar comportamientos o funcionalidades no documentados o simplemente
  *deprecar* alguna función que usemos.

Por eso, hay que asegurarse para el lenguaje con el que se esté trabajando (y
eventualmetne otras herramientas, como un framework de test) que los tests pasen
correctamente en estas tres circunstancias.

Aparte de estas decisiones, preparar un proyecto para integración continua
implica varias cosas:

- Buscar un sistema online de prueba del código que sea estándar y flexible, es
  decir, las propias *GitHub Actions* de GitHub o un servicio gratuito (o
  *freemium*) de integración continua tal como Circle CI o Semaphore CI. Habrá
  que darse de alta en ese sistema, o en el caso de GitHub Actions, simplemente
  incluir una acción en el directorio correspondiente.

- En general, un sistema de CI tendrá un DSL para configurar la infraestructura
  virtual sobre la que se lanzan los tests; la mayoría podrán  usar también
  contenedores de forma que el usuario defina esa infraestructura como desee. En
  este objetivo se pide que al menos se use uno que permita emplear el
  contenedor directamente.

- Finalmente, tras darse de alta, configurar los sistema de integración continua
  de forma que lance los tests automáticamente. En este objetivo se pide que se
  usen sistemas que se pueda conectar a GitHub, es decir, que se active
  automáticamente al hacer un push a tu repositorio en GitHub. Si se usan varios
  simultáneamente, GitHub envía automáticamente un mensaje a todos los sistemas
  configurados cuando se hace push, siempre que estén configurados.

- Para que sean detectados correctamente por GitHub (y por los tests de la
  asignatura), habrá que configurar el sistema para que [use el *checks
  API*](https://docs.github.com/en/rest/reference/checks).

Esta fase de integración continua es esencial para el posterior
despliegue en la nube sobre el que se probarán técnicas de despliegue
continuo (será el último objetivo de la asignatura).

**Aviso**: este es un caso en el que tanto el mismo GitHub como
CoPilot pueden generar automáticamente el fichero de workflow
completo, *y sistemáticamente lo hacen mal*. Aunque la asignatura está
diseñada para que si se envía algo que no cumpla todas las condiciones
se explique al estudiante qué problemas hay a través del PR, se
ahorrará bastante trabajo tanto al estudiante como a los otros
estudiantes que revisen el PR como al profesor si se hace *a mano*
siguiendo el manual o algún tutorial, entendiéndose así mejor las
diferentes partes del *workflow* y por supuesto la retroalimentación
en el PR y cómo construir otros más complejos.

## Lista de comprobación

Como en los casos anteriores, hay que copiar, pegar y llevar a cabo en tu propio
PR.

```markdown
* [ ] ¿Se han establecido criterios *a priori* para elegir el sistema de
integración continua más conveniente y se han calificado los sistemas que
cumplan esos requisitos según esos criterios?
* [ ] ¿Se han examinado varios sistemas de integración continua?
* [ ] ¿Se han configurado varios sistemas de integración continua?
* [ ] ¿Se ha configurado correctamente el *Checks API* en los sistemas en los que
   sea necesario para que aparezca correctamente en GitHub (y se pueda comprobar
   desde los tests)?
* [ ] ¿Uno de los sistemas configurados permite comprobar cuales son las versiones
   dellenguaje con las que funciona correctamente nuestra aplicación?
* [ ] ¿Se escogen de forma adecuada las versiones del lenguaje que se testean,
   tanto en el sistema de CI como en el contenedor Docker?
* [ ] ¿Se han justificado correctamente las versiones del lenguaje que se están
testeando y se ha comprobado que no se comprueban varias veces lo mismo (la
misma versión en CI y en el contenedor Docker en otro sistema CI?

```

## Entrega de la práctica

Se tendrá que haber actualizado el repositorio que se usara en los hitos
anteriores y añadir al
[fichero de este objetivo](https://github.com/JJ/IV-/blob/master/proyectos/objetivo-6.md)
el nombre del proyecto, el autor y un enlace al mismo y hacer un **pull
request**. El PR tendrá que estar en un milestone/PMV, y por supuesto este
tendrá que incluir como parte lo que se haya creado en este objetivo.

Habrá que añadir una nueva clave `CI` a `iv.yml` indicando el *path* del fichero
donde se ha configurado alguno de los sistemas de integración continua.

## Objetivos a alcanzar

1. Integración continua funcionando y correcta justificación de la misma.
2. Uso correcto del gestor de tareas en todos los casos anteriores.
3. Aprovechamiento del contenedor de Docker generado en el hito anterior en
   alguno de los sistemas de CI, especialmente si hay un cambio o adaptación del
   mismo.
4. Tendrán que testearse diferentes versiones del lenguaje con el que se esté
   trabajando, siguiendo las especificaciones vistas arriba.

## Valoración

El alcanzar este objetivo avanzará, en principio, 5% de la puntuación de este
apartado.
